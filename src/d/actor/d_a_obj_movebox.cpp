//
// Generated by dtk
// Translation Unit: d_a_obj_movebox.cpp
//

#include "d/d_a_obj.h"
#include "d/d_bg_s_movebg_actor.h"
#include "d/d_cc_d.h"
#include "d/d_path.h"
#include "d/d_procname.h"
#include "JSystem/JKernel/JKRHeap.h"
#include "JSystem/JUtility/JUTAssert.h"
#include "d/d_com_inf_game.h"
#include "m_Do/m_Do_mtx.h"
#include "dolphin/types.h"
#include "d/d_bg_s_gnd_chk.h"
#include "d/d_bg_s_wtr_chk.h"
#include "d/d_bg_s_lin_chk.h"

namespace daObjMovebox {
    struct Act_c;
    
    struct Type_Attr {
        /* 0x00 */ s16 m00;
        /* 0x02 */ s16 m02;
        /* 0x04 */ s16 m04;
        /* 0x06 */ s16 m06;
        /* 0x08 */ s16 m08;
        /* 0x0A */ s16 m0A;
        /* 0x0C */ f32 m0C;
        /* 0x10 */ u8 m10[0x14 - 0x10];
        /* 0x14 */ f32 m14;
        /* 0x18 */ f32 m18;
        /* 0x1C */ f32 m1C;
        /* 0x20 */ f32 m20;
        /* 0x24 */ f32 m24;
        /* 0x28 */ f32 m28;
        /* 0x2C */ u8 m2C[0x34 - 0x2C];
        /* 0x34 */ f32 m34;
        /* 0x38 */ s16 m38;
        /* 0x3A */ u8 m3A[0x3C - 0x3A];
        /* 0x3C */ f32 m3C;
        /* 0x40 */ f32 m40;
        /* 0x44 */ u8 m44[0x4C - 0x44];
        /* 0x4C */ f32 m4C;
        /* 0x50 */ f32 m50;
        /* 0x54 */ f32 m54;
        /* 0x58 */ int mModelFileIndex;
        /* 0x5C */ int mDZBFileIndex;
        /* 0x60 */ int mDZBHeapSize;
        /* 0x64 */ f32 m64;
        /* 0x68 */ f32 m68;
        /* 0x6C */ f32 m6C;
        /* 0x70 */ f32 m70;
        /* 0x74 */ f32 m74;
        /* 0x78 */ u32 m78;
        /* 0x7C */ u32 m7C;
        /* 0x80 */ u32 m80;
        /* 0x84 */ u32 m84;
        /* 0x88 */ u8 m88[0x8C - 0x88];
        /* 0x8C */ s16 m8C;
        /* 0x8E */ s16 m8E;
        /* 0x90 */ s16 m90;
        /* 0x92 */ s16 m92;
        /* 0x94 */ s16 m94;
        /* 0x96 */ s16 m96;
        /* 0x98 */ u8 m98[0x9A - 0x98];
        /* 0x9A */ u8 m9A;
        /* 0x9B */ u8 field_9B[0x9C - 0x9B];
    };  // Size: 0x9C
    
    struct BgcSrc_c {
        /* 0x00 */ f32 m00;
        /* 0x04 */ f32 m04;
        /* 0x08 */ f32 m08;
        /* 0x0C */ f32 m0C;
    };
    
    struct Bgc_c {
    public:
        enum State_e {
            BgcState_UNK02 = 0x02,
            BgcState_UNK04 = 0x04,
            BgcState_UNK08 = 0x08,
            BgcState_UNK10 = 0x10,
            BgcState_UNK20 = 0x20,
        };
        
        Bgc_c();
        ~Bgc_c();
        void gnd_pos(const Act_c*, const BgcSrc_c*, int, f32);
        void wrt_pos(const cXyz&);
        void wall_pos(const Act_c*, const BgcSrc_c*, int, s16, f32);
        void proc_vertical(Act_c*);
        bool chk_wall_pre(const Act_c*, const BgcSrc_c*, int, s16);
        bool chk_wall_touch(const Act_c*, const BgcSrc_c*, s16);
        bool chk_wall_touch2(const Act_c*, const BgcSrc_c*, int, s16);
    
    public:
        /* 0x000 */ f32 m000[23];
        /* 0x05C */ int m05C;
        /* 0x060 */ f32 m060;
        /* 0x064 */ cXyz m064[23];
        /* 0x178 */ int m178;
        /* 0x17C */ f32 m17C;
        /* 0x180 */ State_e mStateFlags;
        
        static dBgS_ObjGndChk M_gnd_work[23];
        static dBgS_WtrChk M_wrt_work;
        static dBgS_ObjLinChk M_wall_work[23];
        static const BgcSrc_c M_lin5[5];
        static const BgcSrc_c M_lin20[23];
    };  // Size: 0x184
    
    class EffSmokeCB : public dPa_smokeEcallBack {
    public:
        EffSmokeCB() {}
        virtual ~EffSmokeCB() {}
    
    public:
        /* 0x20 */ u8 field_0x20[0x34 - 0x20];
    };  // Size: 0x34
    
    struct Act_c : public dBgS_MoveBgActor {
    public:
        enum Type {
            TYPE_BREAKABLE_WOODEN_CRATE = 0x0,  // Actor names: Kkiba or DKkiba
            TYPE_BLACK_BOX              = 0x1,  // Actor names: osiBLK0 or DBLK0
            TYPE_BLACK_BOX_WITH_STATUE  = 0x2,  // Actor names: osiBLK1 or DBLK1
            TYPE_BIG_BLACK_BOX          = 0x3,  // Actor names: MpwrB
            TYPE_WOODEN_CRATE           = 0x4,  // Actor names: (N/A)
            TYPE_GOLDEN_CRATE           = 0x5,  // Actor names: Hbox2
            TYPE_METAL_BOX              = 0x6,  // Actor names: Hbox1
            TYPE_METAL_BOX_WITH_SPRING  = 0x7,  // Actor names: Hjump1
            TYPE_WOODEN_CRATE_2         = 0x8,  // Actor names: Hseki2
            TYPE_WOODEN_CRATE_3         = 0x9,  // Actor names: Hseki7
            TYPE_MIRROR                 = 0xA,  // Actor names: Mmrr
            TYPE_BLACK_BOX_2            = 0xB,  // Actor names: MkieBB
            TYPE_MOSSY_BLACK_BOX        = 0xC,  // Actor names: Ecube
        };
        
        enum Mode {
            MODE_WAIT   = 0x0,
            MODE_WALK   = 0x1,
            MODE_AFLOAT = 0x2,
        };
        
        enum Prm_e {
            PRM_TYPE_W = 0x04,
            PRM_TYPE_S = 0x18,
            
            PRM_SWSAVE_W = 0x01,
            PRM_SWSAVE_S = 0x1E,
            
            PRM_SWSAVE1_W = 0x08,
            PRM_SWSAVE1_S = 0x08,
            
            PRM_ITEMNO_W = 0x06,
            PRM_ITEMNO_S = 0x00,
            
            PRM_ITEMSAVE_W = 0x07,
            PRM_ITEMSAVE_S = 0x10,
            
            PRM_BUOY_W = 0x01,
            PRM_BUOY_S = 0x1F,
        };
        
        typedef void (Act_c::*ModeFunc)();
        
        inline s32 Mthd_Create();
        inline BOOL Mthd_Delete();
        
        s32 prm_get_type() const { return daObj::PrmAbstract(this, PRM_TYPE_W, PRM_TYPE_S); }
        s32 prm_get_swSave() const { return daObj::PrmAbstract(this, PRM_SWSAVE_W, PRM_SWSAVE_S); }
        s32 prm_get_swSave1() const;
        s32 prmZ_get_swSave2() const { return mType == TYPE_BLACK_BOX_2 ? 0xFF : (u8)(mPrmZ >> 8); }
        s32 prmZ_get_pathId() const { return mType == TYPE_BLACK_BOX_2 ? 0xFF : (mPrmZ & 0x00FF) >> 0; }
        s32 prmX_get_evId() const { return (mPrmX & 0x00FF) >> 0; }
        s32 prm_get_itemNo() const { return daObj::PrmAbstract(this, PRM_ITEMNO_W, PRM_ITEMNO_S); }
        s32 prm_get_itemSave() const { return daObj::PrmAbstract(this, PRM_ITEMSAVE_W, PRM_ITEMSAVE_S); }
        s32 prm_get_buoy() const { return daObj::PrmAbstract(this, PRM_BUOY_W, PRM_BUOY_S); }
        s32 prm_get_dmy() const; // Unused?
        
        BOOL is_switch1() const { return fopAcM_isSwitch((Act_c*)this, prm_get_swSave1()); };
        BOOL is_switch2() const { return fopAcM_isSwitch((Act_c*)this, prmZ_get_swSave2()); };
        void on_switch1() const { fopAcM_onSwitch((Act_c*)this, prm_get_swSave1()); };
        void on_switch2() const { fopAcM_onSwitch((Act_c*)this, prmZ_get_swSave2()); };
        void off_switch1() const { fopAcM_offSwitch((Act_c*)this, prm_get_swSave1()); };
        void off_switch2() const { fopAcM_offSwitch((Act_c*)this, prmZ_get_swSave2()); };
        
        void mode_proc_call() {
            static ModeFunc mode_proc[] = {
                &mode_wait,
                &mode_walk,
                &mode_afl,
            };
            (this->*mode_proc[mMode])();
        }
        
        void prmZ_init();
        void prmX_init();
        const Type_Attr* attr() const; // TODO weak?
        void set_mtx();
        void init_mtx();
        void path_init();
        void path_save();
        int CreateHeap();
        static void RideCallBack(dBgW*, fopAc_ac_c*, fopAc_ac_c*);
        static fopAc_ac_c* PPCallBack(fopAc_ac_c*, fopAc_ac_c*, s16, dBgW::PushPullLabel);
        int Create();
        void afl_sway();
        void check_to_walk();
        void clr_moment_cnt();
        bool chk_appear() const;
        void eff_set_slip_smoke_pos();
        void eff_smoke_slip_start();
        void eff_smoke_slip_end();
        void eff_smoke_slip_remove();
        void mode_wait_init();
        void mode_wait();
        void mode_walk_init();
        void mode_walk();
        void mode_afl_init();
        void mode_afl();
        void make_item();
        void eff_break();
        void sound_break();
        void sound_slip();
        void sound_limit();
        void sound_land();
        void vib_land();
        void eff_land_smoke();
        int Execute(Mtx**);
        int Draw();
        int Delete();
    
    public:
        /* 0x2C8 */ request_of_phase_process_class mPhs;
        /* 0x2D0 */ Mtx mMtx;
        /* 0x300 */ J3DModel* mpModel;
        /* 0x304 */ int mMode;
        /* 0x308 */ dCcD_Stts mStts;
        /* 0x344 */ dCcD_Cyl mCyl;
        /* 0x474 */ Bgc_c mBgc;
        /* 0x5F8 */ s32 mType;
        /* 0x5FC */ u16 mPrmZ;
        /* 0x5FE */ u16 mPrmX;
        /* 0x600 */ dPath* mpPath;
        /* 0x604 */ s16 m604;
        /* 0x606 */ u8 m606[0x608 - 0x606];
        /* 0x608 */ f32 m608;
        /* 0x60C */ f32 m60C;
        /* 0x610 */ f32 m610;
        /* 0x614 */ f32 m614;
        /* 0x618 */ f32 m618;
        /* 0x61C */ f32 m61C;
        /* 0x620 */ f32 m620;
        /* 0x624 */ f32 m624;
        /* 0x628 */ int m628;
        /* 0x62C */ int m62C;
        /* 0x630 */ f32 m630;
        /* 0x634 */ int m634;
        /* 0x638 */ u32 mPPLabel;
        /* 0x63C */ s16 mMomentCnt[4];
        /* 0x644 */ s16 m644;
        /* 0x646 */ s16 m646;
        /* 0x648 */ s16 m648;
        /* 0x64A */ bool m64A;
        /* 0x64B */ u8 mReverb;
        /* 0x64C */ bool mbShouldAppear;
        /* 0x64D */ bool mbPrmZInitialized;
        /* 0x64E */ bool mbPrmXInitialized;
        /* 0x64F */ bool m64F;
        /* 0x650 */ EffSmokeCB mSmokeCbs[2];
        /* 0x6B8 */ u32 mChildProcId;
        /* 0x6BC */ int m6BC;
        
        static const char* const M_arcname[13];
        static const dCcD_SrcCyl M_cyl_src;
        static const Type_Attr M_attr[13];
    };
    
    STATIC_ASSERT(sizeof(Act_c) == 0x6C0);
    
    dBgS_ObjGndChk Bgc_c::M_gnd_work[23];
    dBgS_WtrChk Bgc_c::M_wrt_work;
    dBgS_ObjLinChk Bgc_c::M_wall_work[23];
    
    const BgcSrc_c Bgc_c::M_lin5[5] = {
        // TODO
    };
    
    const BgcSrc_c Bgc_c::M_lin20[23] = {
        // TODO
    };
    
    s32 Act_c::Mthd_Create() {
        fopAcM_SetupActor(this, Act_c);
        
        s32 phase_state;
        mType = prm_get_type();
        phase_state = cPhs_ERROR_e;
        prmX_init();
        prmZ_init();
        
        mbShouldAppear = chk_appear();
        if (mbShouldAppear) {
            phase_state = dComIfG_resLoad(&mPhs, M_arcname[mType]);
            if (phase_state == cPhs_COMPLEATE_e) {
                const Type_Attr* attr = &M_attr[mType];
                u32 heapSize = attr->mDZBHeapSize;
                path_init();
                attr = &M_attr[mType];
                phase_state = MoveBGCreate(M_arcname[mType], attr->mDZBFileIndex, dBgS_MoveBGProc_Trans, heapSize);
                JUT_ASSERT(0x7CE, (phase_state == cPhs_COMPLEATE_e) || (phase_state == cPhs_ERROR_e));
            }
        }
        
        return phase_state;
    }
    
    BOOL Act_c::Mthd_Delete() {
        s32 result = MoveBGDelete();
        if (mbShouldAppear) {
            dComIfG_resDelete(&mPhs, M_arcname[mType]);
        }
        return result;
    }
    
    /* 000000EC-000001B0       .text __ct__Q212daObjMovebox5Bgc_cFv */
    Bgc_c::Bgc_c() {
        /* Nonmatching (rodata only) */
        for (int i = 0; i < ARRAY_SIZE(m000); i++) {
            m000[i] = 0.0f;
            m064[i] = cXyz::Zero;
        }
        m05C = -1;
        m178 = -1;
        m17C = FLOAT_MAX;
        m060 = 0.0f;
        mStateFlags = (State_e)0;
    }
    
    /* 000001F0-000003A4       .text gnd_pos__Q212daObjMovebox5Bgc_cFPCQ212daObjMovebox5Act_cPCQ212daObjMovebox8BgcSrc_cif */
    void Bgc_c::gnd_pos(const Act_c* movebox, const BgcSrc_c* bgcSrc, int param_3, f32 param_4) {
        /* Nonmatching */
        f32 tempz;
        f32 temp3 = -1000000000.0f;
        
        mDoMtx_stack_c::transS(movebox->current.pos);
        mDoMtx_stack_c::YrotM(movebox->orig.angle.y);
        m05C = -1;
        
        for (int i = 0; i < param_3; i++, bgcSrc++) {
            tempz = bgcSrc->m08 + bgcSrc->m00 * movebox->attr()->m70;
            f32 tempy = param_4;
            f32 tempx = bgcSrc->m0C + bgcSrc->m04 * movebox->attr()->m70;
            cXyz temp_14(tempx, tempy, tempz);
            cXyz temp_08;
            mDoMtx_stack_c::multVec(&temp_14, &temp_08);
            M_gnd_work[i].SetPos(&temp_08);
            M_gnd_work[i].SetActorPid(movebox->mBase.mBsPcId);
            m000[i] = dComIfG_Bgsp()->GroundCross(&M_gnd_work[i]);
            if (m000[i] > temp3) {
                fopAc_ac_c* temp = dComIfG_Bgsp()->GetActorPointer(M_gnd_work[i].GetBgIndex());
                if (!(temp && fopAcM_GetName(temp) == PROC_Obj_Movebox && ((Act_c*)temp)->mMode == Act_c::MODE_AFLOAT)) {
                    temp3 = m000[i];
                    m05C = i;
                }
            }
        }
    }
    
    /* 000003A4-00000474       .text wrt_pos__Q212daObjMovebox5Bgc_cFRC4cXyz */
    void Bgc_c::wrt_pos(const cXyz& pos) {
        cXyz groundPos(pos);
        f32 roofY = pos.y + 400.0f;
        groundPos.y -= 100.0f;
        M_wrt_work.Set(groundPos, roofY);
        if (dComIfG_Bgsp()->SplGrpChk(&M_wrt_work)) {
            m060 = M_wrt_work.GetHeight();
            cLib_onBit(mStateFlags, BgcState_UNK08);
            if (m060 > pos.y) {
                cLib_onBit(mStateFlags, BgcState_UNK10);
            }
        }
    }
    
    /* 00000474-00000748       .text wall_pos__Q212daObjMovebox5Bgc_cFPCQ212daObjMovebox5Act_cPCQ212daObjMovebox8BgcSrc_cisf */
    void Bgc_c::wall_pos(const Act_c*, const BgcSrc_c*, int, s16, f32) {
        /* Nonmatching */
    }
    
    /* 00000748-000008E8       .text proc_vertical__Q212daObjMovebox5Bgc_cFPQ212daObjMovebox5Act_c */
    void Bgc_c::proc_vertical(Act_c*) {
        /* Nonmatching */
    }
    
    /* 000008E8-00000928       .text chk_wall_pre__Q212daObjMovebox5Bgc_cFPCQ212daObjMovebox5Act_cPCQ212daObjMovebox8BgcSrc_cis */
    bool Bgc_c::chk_wall_pre(const Act_c* movebox, const BgcSrc_c* bgcSrc, int param_3, s16 param_4) {
        wall_pos(movebox, bgcSrc, param_3, param_4, 74.0f);
        return m178 >= 0;
    }
    
    /* 00000928-00000CCC       .text chk_wall_touch__Q212daObjMovebox5Bgc_cFPCQ212daObjMovebox5Act_cPCQ212daObjMovebox8BgcSrc_cs */
    bool Bgc_c::chk_wall_touch(const Act_c*, const BgcSrc_c*, s16) {
        /* Nonmatching */
    }
    
    /* 00001258-000012E0       .text chk_wall_touch2__Q212daObjMovebox5Bgc_cFPCQ212daObjMovebox5Act_cPCQ212daObjMovebox8BgcSrc_cis */
    bool Bgc_c::chk_wall_touch2(const Act_c* movebox, const BgcSrc_c* bgcSrc, int param_3, s16 param_4) {
        bool touch = false;
        for (int i = 0; i < param_3; i++) {
            if (chk_wall_touch(movebox, &bgcSrc[i], param_4)) {
                touch = true;
                break;
            }
        }
        return touch;
    }
    
    const char* const Act_c::M_arcname[13] = {
        "Kkiba_00",
        "Osiblk",
        "Osiblk",
        "MpwrB",
        "Kkiba_00",
        "Hbox2",
        "Hjump",
        "Hjump",
        "Kkiba_00",
        "Kkiba_00",
        "Mmirror",
        "Osiblk",
        "Ecube",
    };
    
    const dCcD_SrcCyl Act_c::M_cyl_src = {
        // dCcD_SrcGObjInf
        {
            /* Flags             */ 0,
            /* SrcObjAt Type     */ 0,
            /* SrcObjAt Atp      */ 0,
            /* SrcObjAt SPrm     */ 0,
            /* SrcObjTg Type     */ AT_TYPE_BOMB,
            /* SrcObjTg SPrm     */ 0x09,
            /* SrcObjCo SPrm     */ 0x79,
            /* SrcGObjAt Se      */ 0,
            /* SrcGObjAt HitMark */ 0,
            /* SrcGObjAt Spl     */ 0,
            /* SrcGObjAt Mtrl    */ 0,
            /* SrcGObjAt GFlag   */ 0,
            /* SrcGObjTg Se      */ 0,
            /* SrcGObjTg HitMark */ 0,
            /* SrcGObjTg Spl     */ 0,
            /* SrcGObjTg Mtrl    */ 0,
            /* SrcGObjTg GFlag   */ 0,
            /* SrcGObjCo GFlag   */ 0,
        },
        // cM3dGCylS
        {
            /* Center */ 0.0f, 0.0f, 0.0f,
            /* Radius */ 75.0f,
            /* Height */ 150.0f,
        },
    };
    
    const Type_Attr Act_c::M_attr[13] = {
        // TYPE_BREAKABLE_WOODEN_CRATE
        // Arcname: Kkiba_00
        {
            // TODO
            /* mModelFileIndex */ 4,
            /* mDZBFileIndex   */ 7,
            /* mDZBMaxSize     */ 0x8A0,
        },
        // TYPE_BLACK_BOX
        // Arcname: Osiblk
        {
            // TODO
            /* mModelFileIndex */ 4,
            /* mDZBFileIndex   */ 8,
            /* mDZBMaxSize     */ 0x8A0,
        },
        // TYPE_BLACK_BOX_WITH_STATUE
        // Arcname: Osiblk
        {
            // TODO
            /* mModelFileIndex */ 5,
            /* mDZBFileIndex   */ 9,
            /* mDZBMaxSize     */ 0x1560,
        },
        // TYPE_BIG_BLACK_BOX
        // Arcname: MpwrB
        {
            // TODO
        },
        // TYPE_WOODEN_CRATE
        // Arcname: Kkiba_00
        {
            // TODO
        },
        // TYPE_GOLDEN_CRATE
        // Arcname: Hbox2
        {
            // TODO
        },
        // TYPE_METAL_BOX
        // Arcname: Hjump
        {
            // TODO
        },
        // TYPE_METAL_BOX_WITH_SPRING
        // Arcname: Hjump
        {
            // TODO
        },
        // TYPE_WOODEN_CRATE_2
        // Arcname: Kkiba_00
        {
            // TODO
        },
        // TYPE_WOODEN_CRATE_3
        // Arcname: Kkiba_00
        {
            // TODO
        },
        // TYPE_MIRROR
        // Arcname: Mmirror
        {
            // TODO
        },
        // TYPE_BLACK_BOX_2
        // Arcname: Osiblk
        {
            // TODO
        },
        // TYPE_MOSSY_BLACK_BOX
        // Arcname: Ecube
        {
            // TODO
        },
    };
    
    /* 000012E0-00001308       .text prm_get_swSave1__Q212daObjMovebox5Act_cCFv */
    s32 Act_c::prm_get_swSave1() const {
        return daObj::PrmAbstract(this, PRM_SWSAVE1_W, PRM_SWSAVE1_S);
    }
    
    /* 00001308-00001380       .text prmZ_init__Q212daObjMovebox5Act_cFv */
    void Act_c::prmZ_init() {
        if (mbPrmZInitialized) {
            return;
        }
        mbPrmZInitialized = true;
        
        s32 switchEnablesSpawn = prm_get_swSave();
        if (switchEnablesSpawn) {
            // The appearing/disappearing type of box does not take pathId or swSave2 params.
            mPrmZ = 0xFFFF;
        } else {
            mPrmZ = orig.angle.z;
        }
        
        orig.angle.z = 0;
        current.angle.z = 0;
        shape_angle.z = 0;
    }
    
    /* 00001380-000013B0       .text prmX_init__Q212daObjMovebox5Act_cFv */
    void Act_c::prmX_init() {
        if (!mbPrmXInitialized) {
            mPrmX = orig.angle.x;
            mbPrmXInitialized = true;
        }
        
        orig.angle.x = 0;
        current.angle.x = 0;
        shape_angle.x = 0;
    }
    
    /* 000013B0-000013C8       .text attr__Q212daObjMovebox5Act_cCFv */
    const Type_Attr* Act_c::attr() const {
        return &M_attr[mType];
    }
    
    /* 000013C8-00001674       .text set_mtx__Q212daObjMovebox5Act_cFv */
    void Act_c::set_mtx() {
        /* Nonmatching */
        cXyz temp_40;
        Quaternion temp_30;
        Mtx temp4;
        Vec temp5;
        
        bool isFloating = mMode == MODE_AFLOAT;
        mDoMtx_stack_c::transS(current.pos);
        if (isFloating) {
            temp_40.set(m614, 1.0f, m618);
            mDoMtx_stack_c::transM(0.0f, m624, 0.0f);
            daObj::quat_rotBaseY(&temp_30, temp_40);
            mDoMtx_stack_c::quatM(&temp_30);
        }
        
        mDoMtx_stack_c::ZXYrotM(shape_angle);
        if (isFloating) {
            mDoMtx_stack_c::transM(0.0f, -m624, 0.0f);
        }
        
        if (mpModel) {
            mpModel->setBaseTRMtx(mDoMtx_stack_c::get());
        }
        MTXCopy(mDoMtx_stack_c::get(), mMtx);
        
        fopAc_ac_c* buoy;
        if (mChildProcId != -1 && fopAcM_SearchByID(mChildProcId, &buoy)) {
            if (mType == TYPE_METAL_BOX_WITH_SPRING) {
                if (buoy->current.pos.abs2(current.pos) < 0.0001f) {
                    buoy->current.pos = current.pos;
                    // TODO: child actor members
                }
            } else if (mType == TYPE_MIRROR) {
                if (buoy->current.pos.abs2(current.pos) < 0.0001f) {
                    buoy->current.pos = current.pos;
                    // TODO: child actor members
                }
            } else if (mType == TYPE_BLACK_BOX_2) {
                if (buoy->current.pos.abs2(current.pos) < 0.0001f) {
                    buoy->current.pos = current.pos;
                    // TODO: child actor members
                }
            } else {
                cXyz temp_18;
                cXyz temp_0C;
                mDoMtx_stack_c::multVecSR(&temp_18, &temp_0C);
                mDoMtx_stack_c::now[0][3] += temp_0C.x;
                mDoMtx_stack_c::now[1][3] += temp_0C.y;
                mDoMtx_stack_c::now[2][3] += temp_0C.z;
                mDoMtx_stack_c::copy(temp4);
                // TODO: child actor members
            }
        } else {
            mChildProcId = -1;
        }
    }
    
    /* 00001674-000016B8       .text init_mtx__Q212daObjMovebox5Act_cFv */
    void Act_c::init_mtx() {
        if (mpModel) {
            mpModel->mBaseScale = mScale;
        }
        set_mtx();
    }
    
    /* 000016B8-00001830       .text path_init__Q212daObjMovebox5Act_cFv */
    void Act_c::path_init() {
        // Load the position the box was last left pushed to based on the path and switch(es).
        s32 pathId = prmZ_get_pathId();
        s32 swSave1 = prm_get_swSave1();
        if (pathId != 0xFF && swSave1 != 0xFF) {
            s32 swSave2 = prmZ_get_swSave2();
            
            bool isMoved1 = is_switch1();
            u32 isMoved2 = false;
            if (0xFF == swSave2) { // Literal must be on the left hand side for a match
                isMoved2 = false;
            } else {
                isMoved2 = is_switch2();
                isMoved2 = !!isMoved2;
            }
            isMoved2 = !!isMoved2;
            
            s32 pntIdx = 0;
            if (isMoved1 != false) {
                pntIdx = 1;
            }
            if (isMoved2) {
                pntIdx += 2;
            }
            
            mpPath = dPath_GetRoomPath(pathId, orig.roomNo);
            dPath__Point* pnt = dPath_GetPnt(mpPath, pntIdx);
            orig.pos = pnt->mPos;
            current.pos = pnt->mPos;
        }
    }
    
    /* 00001830-00001A10       .text path_save__Q212daObjMovebox5Act_cFv */
    void Act_c::path_save() {
        /* Nonmatching (rodata only) */
        // Determine how far along the path the box has been pushed and save the position to the switch(es).
        // Supports up to 4 possible path points.
        s32 pathId = prmZ_get_pathId();
        s32 swSave1 = prm_get_swSave1();
        if (pathId != 0xFF && swSave1 != 0xFF) {
            s32 swSave2 = prmZ_get_swSave2();
            
            s32 numPnts;
            if (0xFF == swSave2) { // Literal must be on the left hand side for a match
                numPnts = 2;
            } else {
                numPnts = 4;
            }
            if (numPnts > mpPath->m_num) {
                numPnts = mpPath->m_num;
            }
            
            s32 pntIdx;
            for (pntIdx = 0; pntIdx < numPnts; pntIdx++) {
                cXyz pntPos = dPath_GetPnt(mpPath, pntIdx)->mPos;
                if (current.pos.abs2(pntPos) < 9.0f) {
                    break;
                }
            }
            if (pntIdx >= numPnts) {
                return;
            }
            
            // Store the low bit of the 2-bit index in swSave1.
            if (pntIdx & 1) {
                on_switch1();
            } else {
                off_switch1();
            }
            
            if (swSave2 != 0xFF) {
                // Store the high bit of the 2-bit index in swSave2.
                if (pntIdx & 2) {
                    on_switch2();
                } else {
                    off_switch2();
                }
            }
        }
    }
    
    /* 00001A10-00001B00       .text CreateHeap__Q212daObjMovebox5Act_cFv */
    int Act_c::CreateHeap() {
        BOOL success = TRUE;
        const Type_Attr* attr = &M_attr[mType];
        if (attr->mModelFileIndex >= 0) {
            J3DModelData* modelData = (J3DModelData*)dComIfG_getObjectRes(M_arcname[mType], attr->mModelFileIndex);
            JUT_ASSERT(0x6BA, modelData != 0);
            
            mpModel = mDoExt_J3DModel__create(modelData, 0x80000, 0x11000022);
            success = (mpModel != 0);
        } else {
            mpModel = NULL;
        }
        return success;
    }
    
    /* 00001B00-00001C64       .text RideCallBack__Q212daObjMovebox5Act_cFP4dBgWP10fopAc_ac_cP10fopAc_ac_c */
    void Act_c::RideCallBack(dBgW*, fopAc_ac_c*, fopAc_ac_c*) {
        /* Nonmatching */
    }
    
    /* 00001C64-00001DD4       .text PPCallBack__Q212daObjMovebox5Act_cFP10fopAc_ac_cP10fopAc_ac_csQ24dBgW13PushPullLabel */
    fopAc_ac_c* Act_c::PPCallBack(fopAc_ac_c* actor, fopAc_ac_c*, s16 rot, dBgW::PushPullLabel pp_label) {
        Act_c* i_this = (Act_c*)actor;
        
        cLib_checkBit(pp_label, static_cast<dBgW::PushPullLabel>(dBgW::PP_UNK1_e | dBgW::PP_UNK2_e));
        dBgW::PushPullLabel orig_pp_label = pp_label;
        pp_label = static_cast<dBgW::PushPullLabel>(pp_label & (dBgW::PP_UNK1_e | dBgW::PP_UNK2_e));
        if (pp_label) {
            const Type_Attr* attr = &M_attr[i_this->mType];
            bool unk;
            if (!attr->m9A) {
                unk = true;
            } else {
                unk = orig_pp_label & dBgW::PP_UNK8_e;
            }
            if (unk) {
                s16 angle = (s16)(pp_label & dBgW::PP_UNK2_e ? rot - 0x8000 : rot) - actor->orig.angle.y;
                int pp_field = 3;
                JUT_ASSERT(0x715, pp_label != pp_field);
                
                i_this->mPPLabel = orig_pp_label;
                
                int whichSide;
                if (angle >= -0x2000 && angle < 0x2000) {
                    whichSide = 0;
                } else if (angle >= 0x2000 && angle < 0x6000) {
                    whichSide = 1;
                } else if (angle >= 0x6000 || angle < -0x6000) {
                    whichSide = 2;
                } else {
                    whichSide = 3;
                }
                
                for (int i = 0; i < 4; i++) {
                    if (i == whichSide) {
                        i_this->mMomentCnt[i] += 1;
                    } else {
                        i_this->mMomentCnt[i] = 0;
                    }
                }
                
                i_this->m64A = true;
            }
        }
        
        return actor;
    }
    
    /* 00001DD4-00002214       .text Create__Q212daObjMovebox5Act_cFv */
    int Act_c::Create() {
        /* Nonmatching */
        m604 = 0;
        m608 = 0.0f;
        m60C = 0.0f;
        m610 = 0.0f;
        m614 = 0.0f;
        m618 = 0.0f;
        m61C = 0.0f;
        m620 = 0.0f;
        m624 = M_attr[mType].m68 * 0.5f;
        m628 = 0;
        m62C = 0;
        m630 = 0.0f;
        m634 = -1;
        mPPLabel = 0;
        clr_moment_cnt();
        m644 = 0;
        m646 = 0;
        m648 = 0x14;
        m64A = false;
        
        mpBgW->SetRideCallback(RideCallBack);
        mpBgW->SetPushPullCallback(PPCallBack);
        mStts.Init(0xFF, 0xFF, this);
        mCyl.Set(M_cyl_src);
        mCyl.SetStts(&mStts);
        mCyl.SetTgVec(*(cXyz*)&cXyz::Zero); // TODO: this doesn't seem right, but it does match
        mCyl.OnTgNoHitMark();
        mCyl.OffCoSetBit();
        
        fopAcM_SetMtx(this, mMtx);
        fopAcM_setCullSizeBox(this,
            M_attr[mType].m8C, M_attr[mType].m8E, M_attr[mType].m90,
            M_attr[mType].m92, M_attr[mType].m94, M_attr[mType].m96
        );
        
        speedF = 0.0f;
        mGravity = M_attr[mType].m14;
        fopAcM_posMoveF(this, NULL);
        mBgc.proc_vertical(this);
        cLib_offBit(mBgc.mStateFlags, static_cast<Bgc_c::State_e>(Bgc_c::BgcState_UNK02 | Bgc_c::BgcState_UNK04 | Bgc_c::BgcState_UNK20));
        
        m64F = true;
        mReverb = dComIfGp_getReverb(fopAcM_GetHomeRoomNo(this));
        
        mChildProcId = -1;
        if (prm_get_buoy() == 0) {
            cXyz buoyPos(current.pos.x, current.pos.y + M_attr[mType].m68 - 5.0f, current.pos.z);
            mChildProcId = fopAcM_createChild(
                PROC_Obj_Buoyflag, fpcM_GetID(this),
                0, &buoyPos,
                fopAcM_GetRoomNo(this), &shape_angle, NULL, -1, NULL
            );
        } else if (mType == TYPE_METAL_BOX_WITH_SPRING) {
            mChildProcId = fopAcM_createChild(
                PROC_Obj_Jump, fpcM_GetID(this),
                0, &current.pos,
                fopAcM_GetRoomNo(this), &shape_angle, NULL, -1, NULL
            );
        } else if (mType == TYPE_MIRROR) {
            mChildProcId = fopAcM_createChild(
                PROC_Obj_Mmrr, fpcM_GetID(this),
                0, &current.pos,
                fopAcM_GetRoomNo(this), &shape_angle, NULL, -1, NULL
            );
        } else if (mType == TYPE_BLACK_BOX_2) {
            cXyz mkiePos(current.pos.x, current.pos.y + 150.0f, current.pos.z);
            u32 mkieParams = prmZ_get_swSave2() << 0x10 | 0x3000;
            mkieParams |= prmZ_get_pathId();
            mChildProcId = fopAcM_createChild(
                PROC_Obj_Mkie, fpcM_GetID(this),
                mkieParams, &mkiePos,
                fopAcM_GetRoomNo(this), &shape_angle, NULL, -1, NULL
            );
        }
        
        init_mtx();
        m6BC = 0;
        mode_wait_init();
        return TRUE;
    }
    
    /* 00002214-000024D4       .text afl_sway__Q212daObjMovebox5Act_cFv */
    void Act_c::afl_sway() {
        /* Nonmatching */
    }
    
    /* 000024D4-00002668       .text check_to_walk__Q212daObjMovebox5Act_cFv */
    void Act_c::check_to_walk() {
        /* Nonmatching */
    }
    
    /* 00002668-0000268C       .text clr_moment_cnt__Q212daObjMovebox5Act_cFv */
    void Act_c::clr_moment_cnt() {
        for (int i = 0; i < 4; i++) {
            mMomentCnt[i] = 0;
        }
    }
    
    /* 0000268C-00002768       .text chk_appear__Q212daObjMovebox5Act_cCFv */
    bool Act_c::chk_appear() const {
        // Boxes that do not have a path to save their position instead use swSave1 to enable or disable spawning.
        s32 pathId = prmZ_get_pathId();
        int sw = prm_get_swSave1();
        if (pathId != 0xFF || sw == 0xFF) {
            return TRUE;
        }
        
        bool switchIsSet = is_switch1();
        bool switchEnablesSpawn = prm_get_swSave();
        bool shouldAppear = false;
        if ((!switchIsSet && !switchEnablesSpawn) || (switchIsSet && switchEnablesSpawn)) {
            shouldAppear = true;
        }
        return shouldAppear;
    }
    
    /* 00002768-0000290C       .text eff_set_slip_smoke_pos__Q212daObjMovebox5Act_cFv */
    void Act_c::eff_set_slip_smoke_pos() {
        /* Nonmatching */
    }
    
    /* 0000290C-00002A14       .text eff_smoke_slip_start__Q212daObjMovebox5Act_cFv */
    void Act_c::eff_smoke_slip_start() {
        /* Nonmatching */
    }
    
    /* 00002A14-00002A74       .text eff_smoke_slip_end__Q212daObjMovebox5Act_cFv */
    void Act_c::eff_smoke_slip_end() {
        for (int i = 0; i < (int)ARRAY_SIZE(mSmokeCbs); i++) {
            mSmokeCbs[i].end();
        }
    }
    
    /* 00002A74-00002AD4       .text eff_smoke_slip_remove__Q212daObjMovebox5Act_cFv */
    void Act_c::eff_smoke_slip_remove() {
        for (int i = 0; i < (int)ARRAY_SIZE(mSmokeCbs); i++) {
            mSmokeCbs[i].end();
        }
    }
    
    /* 00002AD4-00002B48       .text mode_wait_init__Q212daObjMovebox5Act_cFv */
    void Act_c::mode_wait_init() {
        /* Nonmatching (rodata only) */
        speedF = 0.0f;
        const Type_Attr* attr = &M_attr[mType];
        mGravity = attr->m14;
        mpBgW->SetCrrFunc(dBgS_MoveBGProc_Trans);
        clr_moment_cnt();
        m634 = -1;
        mMode = MODE_WAIT;
    }
    
    /* 00002B48-00002D84       .text mode_wait__Q212daObjMovebox5Act_cFv */
    void Act_c::mode_wait() {
        /* Nonmatching */
    }
    
    /* 00002D84-00002DA4       .text mode_walk_init__Q212daObjMovebox5Act_cFv */
    void Act_c::mode_walk_init() {
        /* Nonmatching (rodata only) */
        speedF = 0.0f;
        m64F = false;
        mMode = MODE_WALK;
    }
    
    /* 00002DA4-000031AC       .text mode_walk__Q212daObjMovebox5Act_cFv */
    void Act_c::mode_walk() {
        /* Nonmatching */
    }
    
    /* 000031AC-000031D4       .text mode_afl_init__Q212daObjMovebox5Act_cFv */
    void Act_c::mode_afl_init() {
        /* Nonmatching (rodata only) */
        speedF = 0.0f;
        mpBgW->SetCrrFunc(dBgS_MoveBGProc_Typical);
        mMode = MODE_AFLOAT;
    }
    
    /* 000031D4-000033D8       .text mode_afl__Q212daObjMovebox5Act_cFv */
    void Act_c::mode_afl() {
        /* Nonmatching */
    }
    
    /* 000033D8-00003450       .text make_item__Q212daObjMovebox5Act_cFv */
    void Act_c::make_item() {
        /* Nonmatching */
    }
    
    /* 00003450-00003570       .text eff_break__Q212daObjMovebox5Act_cFv */
    void Act_c::eff_break() {
        /* Nonmatching */
    }
    
    /* 00003570-00003808       .text sound_break__Q212daObjMovebox5Act_cFv */
    void Act_c::sound_break() {
        /* Nonmatching */
    }
    
    /* 00003AE0-00003BA4       .text sound_slip__Q212daObjMovebox5Act_cFv */
    void Act_c::sound_slip() {
        /* Nonmatching */
    }
    
    /* 00003BA4-00003C68       .text sound_limit__Q212daObjMovebox5Act_cFv */
    void Act_c::sound_limit() {
        /* Nonmatching */
    }
    
    /* 00003C68-00003D2C       .text sound_land__Q212daObjMovebox5Act_cFv */
    void Act_c::sound_land() {
        /* Nonmatching */
    }
    
    /* 00003D2C-00003D80       .text vib_land__Q212daObjMovebox5Act_cFv */
    void Act_c::vib_land() {
        /* Nonmatching */
    }
    
    /* 00003D80-00003E04       .text eff_land_smoke__Q212daObjMovebox5Act_cFv */
    void Act_c::eff_land_smoke() {
        /* Nonmatching */
    }
    
    /* 00003E04-000040D0       .text Execute__Q212daObjMovebox5Act_cFPPA3_A4_f */
    BOOL Act_c::Execute(Mtx**) {
        /* Nonmatching */
        mCyl.ChkTgHit();
        make_item();
        eff_break();
        sound_break();
        fopAcM_delete(this);
        fopAcM_seStart(this, JA_SE_LK_SW_HIT_S, 0x35);
        mode_afl_init();
        mode_afl_init();
        mode_wait_init();
        mode_proc_call();
        sound_land();
        vib_land();
        eff_land_smoke();
        set_mtx();
    }
    
    /* 000040D0-00004254       .text Draw__Q212daObjMovebox5Act_cFv */
    BOOL Act_c::Draw() {
        /* Nonmatching */
    }
    
    /* 00004254-000042A0       .text Delete__Q212daObjMovebox5Act_cFv */
    BOOL Act_c::Delete() {
        eff_smoke_slip_remove();
        if (mpBgW) {
            mpBgW->mpRideCb = NULL;
            mpBgW->mpPushPullCb = NULL;
        }
        return TRUE;
    }
    
    namespace {
        /* 000042A0-000044E0       .text Mthd_Create__Q212daObjMovebox29@unnamed@d_a_obj_movebox_cpp@FPv */
        s32 Mthd_Create(void* i_this) {
            return ((Act_c*)i_this)->Mthd_Create();
        }
        
        /* 000044E0-00004544       .text Mthd_Delete__Q212daObjMovebox29@unnamed@d_a_obj_movebox_cpp@FPv */
        BOOL Mthd_Delete(void* i_this) {
            return ((Act_c*)i_this)->Mthd_Delete();
        }
        
        /* 00004544-00004564       .text Mthd_Execute__Q212daObjMovebox29@unnamed@d_a_obj_movebox_cpp@FPv */
        BOOL Mthd_Execute(void* i_this) {
            return ((Act_c*)i_this)->MoveBGExecute();
        }
        
        /* 00004564-00004590       .text Mthd_Draw__Q212daObjMovebox29@unnamed@d_a_obj_movebox_cpp@FPv */
        BOOL Mthd_Draw(void* i_this) {
            return ((Act_c*)i_this)->Draw();
        }
        
        /* 00004590-000045BC       .text Mthd_IsDelete__Q212daObjMovebox29@unnamed@d_a_obj_movebox_cpp@FPv */
        BOOL Mthd_IsDelete(void* i_this) {
            return ((Act_c*)i_this)->IsDelete();
        }
        
        static actor_method_class Mthd_Table = {
            (process_method_func)Mthd_Create,
            (process_method_func)Mthd_Delete,
            (process_method_func)Mthd_Execute,
            (process_method_func)Mthd_IsDelete,
            (process_method_func)Mthd_Draw,
        };
    }
}

actor_process_profile_definition g_profile_Obj_Movebox = {
    /* LayerID      */ fpcLy_CURRENT_e,
    /* ListID       */ 3,
    /* ListPrio     */ fpcLy_CURRENT_e,
    /* ProcName     */ PROC_Obj_Movebox,
    /* Proc SubMtd  */ &g_fpcLf_Method.mBase,
    /* Size         */ sizeof(daObjMovebox::Act_c),
    /* SizeOther    */ 0,
    /* Parameters   */ 0,
    /* Leaf SubMtd  */ &g_fopAc_Method.base,
    /* Priority     */ 0x0015,
    /* Actor SubMtd */ &daObjMovebox::Mthd_Table,
    /* Status       */ 0x04 | fopAcStts_SHOWMAP_e | fopAcStts_CULL_e | fopAcStts_FREEZE_e | fopAcStts_UNK40000_e,
    /* Group        */ fopAc_ACTOR_e,
    /* CullType     */ fopAc_CULLBOX_CUSTOM_e,
};
