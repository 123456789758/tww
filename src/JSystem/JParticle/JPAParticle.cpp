//
// Generated by dtk
// Translation Unit: JPAParticle.cpp
//

#include "JSystem/JParticle/JPAParticle.h"
#include "JSystem/JParticle/JPAEmitter.h"
#include "JSystem/JParticle/JPASweepShape.h"
#include "dolphin/mtx/mtxvec.h"

/* 8025DEF4-8025E62C       .text initParticle__15JPABaseParticleFv */
void JPABaseParticle::initParticle() {
    JPABaseEmitter * emtr = JPABaseEmitter::emtrInfo.mpCurEmitter;
    mStatus = 0x01;
    mFieldAccel.set(1.0f, 1.0f, 1.0f);
    mFieldDrag = 1.0f;
    mDrag = 1.0f;
    MTXMultVec(JPABaseEmitter::emtrInfo.mEmitterGlobalSR, JPABaseEmitter::emtrInfo.mVolumePos, mLocalPosition);
    if ((emtr->mDataFlag & 0x08) != 0)
        mStatus |= 0x20;
    mGlobalPosition = JPABaseEmitter::emtrInfo.mEmitterGlobalCenter;
    // TODO: calculate vel/pos
    mpCallBack2 = emtr->mpParticleCallBack;
    emtr->mFieldManager.init(this);
    field_0xd0 = 0;
}

/* 8025E62C-8025EB28       .text initChild__15JPABaseParticleFP15JPABaseParticle */
void JPABaseParticle::initChild(JPABaseParticle* parent) {
    /* Nonmatching */
}

/* 8025EB28-8025EB90       .text incFrame__15JPABaseParticleFv */
void JPABaseParticle::incFrame() {
    mCurFrame += 1.0f;
    if (mCurFrame < 0.0f)
        mCurFrame = 0.0f;

    mStatus &= ~0x01;

    if (mCurFrame >= mLifeTime) {
        mCurNormTime = 1.0f;
        mStatus |= 0x02;
    } else {
        mCurNormTime = mCurFrame / mLifeTime;
    }
}

/* 8025EB90-8025ECE8       .text calcVelocity__15JPABaseParticleFv */
void JPABaseParticle::calcVelocity() {
    mFieldVel.zero();
    if (mStatus & 0x20)
        mGlobalPosition.set(JPABaseEmitter::emtrInfo.mEmitterGlobalCenter);
    mBaseVel.x += mAccel.x;
    mBaseVel.y += mAccel.y;
    mBaseVel.z += mAccel.z;
    if (!(mStatus & 0x40))
        JPABaseEmitter::emtrInfo.mpCurEmitter->mFieldManager.calc(this);
    mFieldVel.x += mFieldAccel.x;
    mFieldVel.y += mFieldAccel.y;
    mFieldVel.z += mFieldAccel.z;

    f32 airResist = mAirResist;
    mBaseVel.x *= airResist;
    mBaseVel.y *= airResist;
    mBaseVel.z *= airResist;

    f32 velScale = mMoment * mDrag;
    JGeometry::TVec3<f32> vel;
    vel.x = (mBaseVel.x + mFieldVel.x) * velScale;
    vel.y = (mBaseVel.y + mFieldVel.y) * velScale;
    vel.z = (mBaseVel.z + mFieldVel.z) * velScale;

    mVelocity = vel;
}

/* 8025ECE8-8025ED6C       .text calcPosition__15JPABaseParticleFv */
void JPABaseParticle::calcPosition() {
    mLocalPosition.x += mVelocity.x;
    mLocalPosition.y += mVelocity.y;
    mLocalPosition.z += mVelocity.z;

    mPosition.set(
        mLocalPosition.x * JPABaseEmitter::emtrInfo.mPublicScale.x + mGlobalPosition.x,
        mLocalPosition.y * JPABaseEmitter::emtrInfo.mPublicScale.y + mGlobalPosition.y,
        mLocalPosition.z * JPABaseEmitter::emtrInfo.mPublicScale.z + mGlobalPosition.z
    );
}

/* 8025ED6C-8025EE44       .text checkCreateChild__15JPABaseParticleFv */
bool JPABaseParticle::checkCreateChild() {
    JPASweepShape * ssp = JPABaseEmitter::emtrInfo.mpCurEmitter->mpDataLinkInfo->getSweepShape();
    bool ret = false;
    f32 time = mLifeTime > 1.0f ? (mCurFrame / (mLifeTime - 1.0f)) : 1.0f;
    if (time >= ssp->getTiming()) {
        f32 frame = mCurFrame;
        s32 step = (ssp->getStep() & 0xFF) + 1;
        if (((s32)frame % step) == 0)
            ret = true;
    }
    return ret;
}
