//
// Generated by dtk
// Translation Unit: JPABaseShape.cpp
//

#include "JSystem/JParticle/JPABaseShape.h"
#include "JSystem/JKernel/JKRHeap.h"
#include "JSystem/JUtility/JUTAssert.h"

GXBlendMode JPABaseShapeArc::stBlendMode[4] = {
    GX_BM_NONE,
    GX_BM_BLEND,
    GX_BM_LOGIC,
};

GXBlendFactor JPABaseShapeArc::stBlendFactor[10] = {
    GX_BL_ZERO,
    GX_BL_ONE,
    GX_BL_SRC_COLOR,
    GX_BL_INV_SRC_COLOR,
    GX_BL_DST_COLOR,
    GX_BL_INV_DST_COLOR,
    GX_BL_SRC_ALPHA,
    GX_BL_INV_SRC_ALPHA,
    GX_BL_DST_ALPHA,
    GX_BL_INV_DST_ALPHA,
};

GXLogicOp JPABaseShapeArc::stLogicOp[16] = {
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
    GX_LO_CLEAR,
};

GXCompare JPABaseShapeArc::stCompare[8] = {
    GX_NEVER,
    GX_LESS,
    GX_LEQUAL,
    GX_EQUAL,
    GX_NEQUAL,
    GX_GEQUAL,
    GX_GREATER,
    GX_ALWAYS,
};

GXAlphaOp JPABaseShapeArc::stAlphaOp[4] = {
    GX_AOP_AND,
    GX_AOP_OR,
    GX_AOP_XOR,
    GX_AOP_XNOR,
};

GXTevColorArg JPABaseShapeArc::stTevColorArg[6][4] = {
    { GX_CC_ZERO, GX_CC_TEXC, GX_CC_ONE,  GX_CC_ZERO },
    { GX_CC_ZERO, GX_CC_C0,   GX_CC_TEXC, GX_CC_ZERO },
    { GX_CC_C0,   GX_CC_ONE,  GX_CC_TEXC, GX_CC_ZERO },
    { GX_CC_C1,   GX_CC_C0,   GX_CC_TEXC, GX_CC_ZERO },
    { GX_CC_ZERO, GX_CC_TEXC, GX_CC_C0,   GX_CC_C1   },
    { GX_CC_ZERO, GX_CC_ZERO, GX_CC_ZERO, GX_CC_C0   },
};

GXTevAlphaArg JPABaseShapeArc::stTevAlphaArg[2][4] = {
    { GX_CA_ZERO, GX_CA_TEXA, GX_CA_A0,   GX_CA_ZERO },
    { GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_A0   },
};

class JPAColorRegAnmKey;

/* 80256F88-80257248       .text makeColorTable__FP17JPAColorRegAnmKeyiiP7JKRHeap */
GXColor * makeColorTable(JPAColorRegAnmKey* pKey, int keyNum, int frmNum, JKRHeap* pHeap) {
    /* Nonmatching */
    GXColor * colTbl = (GXColor *)JKRHeap::alloc((frmNum + 1) * sizeof(GXColor), 4, pHeap);
    JUT_ASSERT(0x5d, colTbl);
    return colTbl;
}

/* 80257248-80257508       .text __ct__15JPABaseShapeArcFPCUcP7JKRHeap */
JPABaseShapeArc::JPABaseShapeArc(const u8* pData, JKRHeap* pHeap) {
    /* Nonmatching */
    pBsd = (const JPABaseShapeData*) pData;
    mColLoopOffset = -((u16)(pBsd->mFlags >> 11) & 1);
    mTexLoopOffset = -((u16)(pBsd->mFlags >> 13) & 1);

    bool bFlag2 = false;
    if (!(pBsd->mFlags & 0x1000)) {
        if (getType() == JPAType_Stripe || getType() == JPAType_StripeCross)
            bFlag2 = true;
    }

    bool bFlag1 = false;
    if (!(pBsd->mFlags & 0x4000)) {
        if (getType() == JPAType_Stripe || getType() == JPAType_StripeCross)
            bFlag1 = true;
    }

    mGlobalAnmFlags = bFlag2 << 1 | bFlag1 << 0;
    if (isEnableTextureAnm() && getTextureAnmKeyNum() != 0)
        mpTexAnmIdxArr = (const u8*)(pData + 0x60);
    else
        mpTexAnmIdxArr = NULL;

    if (isEnablePrmAnm()) {
        JUT_ASSERT(0x11f, pBsd->prmAnmKeyNum != 0);
        mpPrmColorArr = makeColorTable((JPAColorRegAnmKey*)(pData + pBsd->mPrmAnimDataOffs), pBsd->prmAnmKeyNum, pBsd->mColorRegAnmMaxFrm, pHeap);
    } else {
        mpPrmColorArr = NULL;
    }

    if (isEnableEnvAnm()) {
        JUT_ASSERT(0x127, pBsd->envAnmKeyNum != 0);
        mpEnvColorArr = makeColorTable((JPAColorRegAnmKey*)(pData + pBsd->mEnvAnimDataOffs), pBsd->envAnmKeyNum, pBsd->mColorRegAnmMaxFrm, pHeap);
    } else {
        mpEnvColorArr = NULL;
    }
}
